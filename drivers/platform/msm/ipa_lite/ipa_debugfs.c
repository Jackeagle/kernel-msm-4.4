/* Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 */

#ifdef CONFIG_DEBUG_FS

#define pr_fmt(fmt)    "ipa %s:%d " fmt, __func__, __LINE__

#include <linux/debugfs.h>
#include <linux/kernel.h>
#include <linux/stringify.h>
#include <linux/stat.h>
#include "ipa_i.h"

#define IPA_MAX_MSG_LEN 4096
#define IPA_DBG_ACTIVE_CLIENT_BUF_SIZE ((IPA3_ACTIVE_CLIENTS_LOG_LINE_LEN \
	* IPA3_ACTIVE_CLIENTS_LOG_BUFFER_SIZE_LINES) + IPA_MAX_MSG_LEN)

#define IPA_DUMP_STATUS_FIELD(f) \
	ipa_err(#f "=0x%x\n", status->f)

static char dbg_buff[IPA_MAX_MSG_LEN];
static char *active_clients_buf;

/*
 * Macros to help in defining simple sequential debugfs files.
 *
 * DEF_SEQ_RO(name) defines most of what's required for a single debugfs
 * file "name" that produces output generated by a sequential file "get"
 * function, which should be defined prior to the the call.  For example:
 *	static int foo_show(struct seq_file *s, void *v)
 *	{
 *		seq_printf(s, "foo!\n");
 *		return 0;
 *	}
 *	DEF_SEQ_RO(foo);
 *
 * If a debugfs file is to be writable, DEF_SEQ_RW should be used, and a
 * write file operation must also be defined:
 *	static int foo_show(struct seq_file *s, void *v)
 *	{
 *		...
 *	}
 *	static ssize_t foo_write(struct file *s, const char __user *buf,
 *		size_t count, loff_t *ppos)
 *	{
 *		... process data written to buf ...
 *		return count;
 *	}
 *	DEF_SEQ_RW(foo);
 *
 * An initialization function should call ADD_SEQ_RO() or ADD_SEQ_RW()
 * to create the file, supplying the dentry for the directory to contain
 * the file, along with the name value that was supplied by the corresponding
 * DEF_SEQ_*(name) call (like "foo" in the above example).
 *
 * Both of these return true if successful, false otherwise.  For example:
 *	if (!ADD_SEQ_RW(parent_dentry, foo))
 *		return -EINVAL;
 */

#define _DEF_SEQ(name, write_fop)					\
static int name ## _open(struct inode *inode, struct file *file)	\
{									\
	return single_open(file, name ## _show, inode->i_private);	\
}									\
									\
static const struct file_operations name ## _fops = {			\
	.owner		= THIS_MODULE,					\
	.open		= name ## _open,				\
	.read		= seq_read,					\
	.write		= (write_fop),					\
	.llseek		= seq_lseek,					\
	.release	= single_release,				\
}

#define DEF_SEQ_RO(name)	_DEF_SEQ(name, NULL)
#define DEF_SEQ_RW(name)	_DEF_SEQ(name, name ## _write)

/*
 * Returns true if creation of the debugfs file succeeded.  The value
 * provided is available in the sequential file "show" function as
 * seq_file->private.  For a writable file, it's available in its
 * "write" file operation via file_inode(file)->i_private.
 **/
#define _ADD_SEQ(dir, file_name, name, mode, val)			\
	({								\
		struct dentry *file;					\
									\
		file = debugfs_create_file(file_name, (mode), (dir),	\
					(void *)(val), &name ## _fops);	\
		!IS_ERR_OR_NULL(file);	/* result */			\
	})

#define _ADD_SEQ_RO(dir, name, val)					\
		_ADD_SEQ(dir, #name, name, S_IFREG|S_IRUGO, val)
#define _ADD_SEQ_RW(dir, name, val)					\
		_ADD_SEQ(dir, #name, name, S_IFREG|S_IRUGO|S_IWUSR, val)

/* The simplest files require no value to be provided */
#define ADD_SEQ_RO(dir, name)	_ADD_SEQ_RO(dir, name, NULL)
#define ADD_SEQ_RW(dir, name)	_ADD_SEQ_RW(dir, name, NULL)

/* Registers use common ipa_reg_show() function and ipa_reg_write() */
#define ADD_REG_RO(dir, reg)						\
		_ADD_SEQ(dir, #reg, ipa_reg, S_IFREG|S_IRUGO, reg)
#define ADD_REG_RW(dir, reg)						\
		_ADD_SEQ(dir, #reg, ipa_reg, S_IFREG|S_IRUGO|S_IWUSR, reg)

/*
 * N-parameterized registers use common ipa_reg_n_show() and
 * ipa_reg_n_write() functions.  The register and n value are
 * encoded in the 64-bit value (IPA only supports 64-bit builds,
 * so pointers are 64 bits).
 */
#define ADD_REG_N_RO(dir, reg, n)					\
		_ADD_SEQ(dir, #reg, ipa_reg_n, S_IFREG|S_IRUGO,		\
					(u64)(reg) << 32 | (u64)n)
#define ADD_REG_N_RW(dir, reg, n)					\
		_ADD_SEQ(dir, #reg, ipa_reg_n, S_IFREG|S_IRUGO|S_IWUSR,	\
					(u64)(reg) << 32 | (u64)n)

/* Registers with fields must supply their own "show" and "write functions */
#define ADD_REG_FIELDS_RO(dir, reg)					\
		_ADD_SEQ(dir, #reg, reg, S_IFREG|S_IRUGO, NULL)
#define ADD_REG_FIELDS_RW(dir, reg)					\
		_ADD_SEQ(dir, #reg, reg, S_IFREG|S_IRUGO|S_IWUSR, NULL)

/* Statistics use a common ipa_stat_show() function and supply their address */
#define _ADD_STAT(dir, stat, val)					\
		_ADD_SEQ(dir, stat, ipa_stat, S_IFREG|S_IRUGO, val)

static ssize_t ipa3_write_ep_holb(struct file *file,
		const char __user *buf, size_t count, loff_t *ppos)
{
	struct ipa_ep_cfg_holb holb;
	u32 en;
	u32 tmr_val;
	u32 ep_idx;
	unsigned long missing;
	char *sptr, *token;

	if (sizeof(dbg_buff) < count + 1)
		return -EFAULT;

	missing = copy_from_user(dbg_buff, buf, count);
	if (missing)
		return -EFAULT;

	dbg_buff[count] = '\0';

	sptr = dbg_buff;

	token = strsep(&sptr, " ");
	if (!token)
		return -EINVAL;
	if (kstrtou32(token, 0, &ep_idx))
		return -EINVAL;

	token = strsep(&sptr, " ");
	if (!token)
		return -EINVAL;
	if (kstrtou32(token, 0, &en))
		return -EINVAL;

	token = strsep(&sptr, " ");
	if (!token)
		return -EINVAL;
	if (kstrtou32(token, 0, &tmr_val))
		return -EINVAL;

	holb.en = en;
	holb.tmr_val = tmr_val;

	ipa3_cfg_ep_holb(ep_idx, &holb);

	return count;
}

static ssize_t ipa3_write_dbg_cnt(struct file *file, const char __user *buf,
		size_t count, loff_t *ppos)
{
	unsigned long missing;
	u32 option = 0;
	struct ipahal_reg_debug_cnt_ctrl dbg_cnt_ctrl;

	if (sizeof(dbg_buff) < count + 1)
		return -EFAULT;

	missing = copy_from_user(dbg_buff, buf, count);
	if (missing)
		return -EFAULT;

	dbg_buff[count] = '\0';
	if (kstrtou32(dbg_buff, 0, &option))
		return -EFAULT;

	memset(&dbg_cnt_ctrl, 0, sizeof(dbg_cnt_ctrl));
	dbg_cnt_ctrl.type = DBG_CNT_TYPE_GENERAL;
	dbg_cnt_ctrl.product = true;
	dbg_cnt_ctrl.src_pipe = 0xff;
	dbg_cnt_ctrl.rule_idx_pipe_rule = false;
	dbg_cnt_ctrl.rule_idx = 0;
	if (option == 1)
		dbg_cnt_ctrl.en = true;
	else
		dbg_cnt_ctrl.en = false;

	ipa_client_add(__func__, false);
	ipahal_write_reg_n_fields(IPA_DEBUG_CNT_CTRL_n, 0, &dbg_cnt_ctrl);
	ipa_client_remove(__func__, false);

	return count;
}

static ssize_t ipa3_read_dbg_cnt(struct file *file, char __user *ubuf,
		size_t count, loff_t *ppos)
{
	int nbytes;
	u32 regval;

	ipa_client_add(__func__, false);
	regval =
		ipahal_read_reg_n(IPA_DEBUG_CNT_REG_n, 0);
	nbytes = scnprintf(dbg_buff, IPA_MAX_MSG_LEN,
			"IPA_DEBUG_CNT_REG_0=0x%x\n", regval);
	ipa_client_remove(__func__, false);

	return simple_read_from_buffer(ubuf, count, ppos, dbg_buff, nbytes);
}

static void ipa_dump_status(struct ipahal_pkt_status *status)
{
	IPA_DUMP_STATUS_FIELD(status_opcode);
	IPA_DUMP_STATUS_FIELD(exception);
	IPA_DUMP_STATUS_FIELD(status_mask);
	IPA_DUMP_STATUS_FIELD(pkt_len);
	IPA_DUMP_STATUS_FIELD(endp_src_idx);
	IPA_DUMP_STATUS_FIELD(endp_dest_idx);
	IPA_DUMP_STATUS_FIELD(metadata);
	IPA_DUMP_STATUS_FIELD(ucp);
	ipa_err("tag = 0x%llx\n", (u64)status->tag_info & 0xFFFFFFFFFFFF);
	IPA_DUMP_STATUS_FIELD(seq_num);
	IPA_DUMP_STATUS_FIELD(time_of_day_ctr);
	IPA_DUMP_STATUS_FIELD(hdr_local);
	IPA_DUMP_STATUS_FIELD(hdr_offset);
	IPA_DUMP_STATUS_FIELD(frag_hit);
	IPA_DUMP_STATUS_FIELD(frag_rule);
}

static ssize_t ipa_status_stats_read(struct file *file, char __user *ubuf,
		size_t count, loff_t *ppos)
{
	struct ipa3_status_stats *stats;
	int i, j;

	stats = kzalloc(sizeof(*stats), GFP_KERNEL);
	if (!stats)
		return -EFAULT;

	for (i = 0; i < ipa3_ctx->ipa_num_pipes; i++) {
		if (!ipa3_ctx->ep[i].sys || !ipa3_ctx->ep[i].sys->status_stat)
			continue;

		memcpy(stats, ipa3_ctx->ep[i].sys->status_stat, sizeof(*stats));
		ipa_err("Statuses for pipe %d\n", i);
		for (j = 0; j < IPA_MAX_STATUS_STAT_NUM; j++) {
			ipa_err("curr=%d\n", stats->curr);
			ipa_dump_status(&stats->status[stats->curr]);
			ipa_err("\n\n\n");
			stats->curr = (stats->curr + 1) %
				IPA_MAX_STATUS_STAT_NUM;
		}
	}

	kfree(stats);
	return 0;
}

static ssize_t ipa3_print_active_clients_log(struct file *file,
		char __user *ubuf, size_t count, loff_t *ppos)
{
	int table_size;

	if (active_clients_buf == NULL) {
		ipa_err("Active Clients buffer is not allocated");
		return 0;
	}
	memset(active_clients_buf, 0, IPA_DBG_ACTIVE_CLIENT_BUF_SIZE);
	mutex_lock(&ipa3_ctx->ipa3_active_clients.mutex);
	table_size = ipa3_active_clients_log_print_table(active_clients_buf,
			IPA_MAX_MSG_LEN);
	mutex_unlock(&ipa3_ctx->ipa3_active_clients.mutex);

	return simple_read_from_buffer(ubuf, count, ppos,
			active_clients_buf, table_size);
}

/*
 * File operation to implement a read for a file whose content
 * is a constant string.  Pass constant string as data parameter
 * to debugfs_create_file().  String should contain a newline
 * (if desired).
 */
static ssize_t
const_string_read_fop(struct file *file, char __user *buf, size_t len,
			loff_t *ppos)
{
	char *string = file_inode(file)->i_private;
	size_t size = strlen(string) + 1;

	return simple_read_from_buffer(buf, len, ppos, string, size);
}

const struct file_operations ipa3_ep_holb_ops = {
	.write = ipa3_write_ep_holb,
};

const struct file_operations ipa3_dbg_cnt_ops = {
	.read = ipa3_read_dbg_cnt,
	.write = ipa3_write_dbg_cnt,
};

const struct file_operations ipa3_status_stats_ops = {
	.read = ipa_status_stats_read,
};

const struct file_operations ipa3_active_clients = {
	.read = ipa3_print_active_clients_log,
};

static const struct file_operations const_string_fops = {
	.read = const_string_read_fop,
};

/*
 * "ipa/ipc_low_enabled" indicates whether low-level IPC logging is enabled.
 *
 * Any write starting with "y" or "1" or "on" requests that IPC logging
 * be enabled; "n" or "0" or "off" disables.  Enable requests when
 * already enabled or disabling when disabled are silently ignored.
 */
static int ipc_low_enabled_show(struct seq_file *s, void *v)
{
	seq_printf(s, "%d\n", ipa3_ctx->logbuf_low ? 1 : 0);

	return 0;
}

static ssize_t ipc_low_enabled_write(struct file *s, const char __user *buf,
		size_t count, loff_t *ppos)
{
	bool enable;
	int ret;

	ret = kstrtobool_from_user(buf, count, &enable);
	if (ret)
		return ret;

	mutex_lock(&ipa3_ctx->lock);

	if (enable) {
		if (ipa3_ctx->logbuf_low)
			goto out_unlock;	/* already enabled */
		ipa3_ctx->logbuf_low = ipc_log_context_create(IPA_IPC_LOG_PAGES,
							"ipa_low", 0);
		if (!ipa3_ctx->logbuf_low)
			ret = -ENOMEM;
	} else if (ipa3_ctx->logbuf_low) {
		/*
		 * Sadly, a bug which I gave up trying to resolve causes
		 * ipc_log_context_destroy() to hang, at least sometimes.
		 * Rather than fix it I'll just leak the log context, as
		 * was done in the code I started with.
		 */
		/* (void)ipc_log_context_destroy(ipa3_ctx->logbuf_low); */
		ipa3_ctx->logbuf_low = NULL;
	}	/* else already disabled */
out_unlock:
	mutex_unlock(&ipa3_ctx->lock);

	return ret ? ret : count;
}
DEF_SEQ_RW(ipc_low_enabled);

/* Common file show operation for registers */
static int ipa_reg_show(struct seq_file *s, void *v)
{
	u64 reg = (u64)s->private;

	ipa_bug_on(reg >= (u64)IPA_REG_MAX);

	ipa_client_add(__func__, false);

	seq_printf(s, "0x%08x\n", ipahal_read_reg((enum ipahal_reg)reg));

	ipa_client_remove(__func__, false);

	return 0;
}

static ssize_t ipa_reg_write(struct file *file, const char __user *buf,
		size_t count, loff_t *ppos)
{
	u64 reg = (u64)file_inode(file)->i_private;
	u32 input;
	int ret;

	ipa_bug_on(reg >= (u32)IPA_REG_MAX);

	ret = kstrtouint_from_user(buf, count, 0, &input);
	if (ret)
		return ret;

	ipa_client_add(__func__, false);

	ipahal_write_reg((enum ipahal_reg)reg, input);

	ipa_client_remove(__func__, false);

	return count;
}
DEF_SEQ_RW(ipa_reg);

/*
 * Common file show operation for n-parameterized registers.  The
 * 32-bit offset and 32-bit n value are encoded in the data argument
 * (a pointer) by interpreting it as two consecutive 32-bit values.
 */
static int ipa_reg_n_show(struct seq_file *s, void *v)
{
	u64 val = (u64)s->private;
	u64 reg = val >> 32;
	u32 n = (u32)(val & GENMASK(31,0));

	ipa_bug_on(reg >= (u32)IPA_REG_MAX);

	ipa_client_add(__func__, false);

	seq_printf(s, "0x%08x\n", ipahal_read_reg_n((enum ipahal_reg)reg, n));

	ipa_client_remove(__func__, false);

	return 0;
}

static ssize_t ipa_reg_n_write(struct file *file, const char __user *buf,
		size_t count, loff_t *ppos)
{
	u64 val = (u64)file_inode(file)->i_private;
	u64 reg = val >> 32;
	u32 n = (u32)(val & GENMASK(31,0));
	u32 input;
	int ret;

	ipa_bug_on(reg >= (u32)IPA_REG_MAX);

	ret = kstrtouint_from_user(buf, count, 0, &input);
	if (ret)
		return ret;

	ipa_client_add(__func__, false);

	ipahal_write_reg_n((enum ipahal_reg)reg, n, input);

	ipa_client_remove(__func__, false);

	return count;
}
DEF_SEQ_RW(ipa_reg_n);

/*
 * "ipa/regs/shared_mem_size" shows the SHARED_MEM_SIZE register.
 *
 * This shows the values of both fields associated with this register.
 */
static int shared_mem_size_show(struct seq_file *s, void *v)
{
	struct ipahal_reg_shared_mem_size reg = { 0 };

	ipa_client_add(__func__, false);

	ipahal_read_reg_fields(IPA_SHARED_MEM_SIZE, &reg);

	ipa_client_remove(__func__, false);

	seq_printf(s, "shared_mem_sz:    0x%08x\n", reg.shared_mem_sz);
	seq_printf(s, "shared_mem_baddr: 0x%08x\n", reg.shared_mem_baddr);

	return 0;
}
DEF_SEQ_RO(shared_mem_size);

/* Common file show operation for statistics */
static int ipa_stat_show(struct seq_file *s, void *v)
{
	u32 *stat = s->private;

	seq_printf(s, "0x%08x\n", *stat);

	return 0;
}
DEF_SEQ_RO(ipa_stat);

/*
 * "ipa/regs/pipe-XX/" is a directory containing pipe registers
 *
 * Each pipe has its own directory, and the "XX" in the name is the
 * hexidecimal number of the pipe.  Files within each directory
 * show the values of registers associated with a pipe.
 */
static bool ipa_debugfs_regs_pipe_create(struct dentry *regs_dir, u32 pipe)
{
	static struct dentry *pipe_dir;
	char name[8];	/* supports up to 256 pipes */
	bool success;

	ipa_assert(pipe <= 0xff);

	(void)snprintf(name, sizeof(name), "pipe-%02x", pipe);

	pipe_dir = debugfs_create_dir(name, regs_dir);
	if (IS_ERR(pipe_dir))
		return false;

	success = ADD_REG_N_RO(pipe_dir, IPA_ENDP_INIT_NAT_n, pipe);
	success = success && ADD_REG_N_RO(pipe_dir, IPA_ENDP_INIT_HDR_n, pipe);
	success = success && ADD_REG_N_RO(pipe_dir,
					IPA_ENDP_INIT_HDR_EXT_n, pipe);
	success = success && ADD_REG_N_RO(pipe_dir, IPA_ENDP_INIT_MODE_n, pipe);
	success = success && ADD_REG_N_RO(pipe_dir, IPA_ENDP_INIT_AGGR_n, pipe);
	/* ENDP_INIT_ROUTE_n won't exist after IPA v3.5.1 */
	success = success && ADD_REG_N_RO(pipe_dir, IPA_ENDP_INIT_ROUTE_n, pipe);
	success = success && ADD_REG_N_RO(pipe_dir, IPA_ENDP_INIT_CTRL_n, pipe);
	success = success && ADD_REG_N_RO(pipe_dir,
					IPA_ENDP_INIT_HOL_BLOCK_EN_n, pipe);
	success = success && ADD_REG_N_RO(pipe_dir,
					IPA_ENDP_INIT_HOL_BLOCK_TIMER_n, pipe);
	success = success && ADD_REG_N_RO(pipe_dir,
					IPA_ENDP_INIT_DEAGGR_n, pipe);
	success = success && ADD_REG_N_RO(pipe_dir, IPA_ENDP_INIT_CFG_n, pipe);

	return success;
}

/*
 * "ipa/regs/" is a directory containing registers and their values.
 *
 * Most files in this directory are read-only.  All registers use a
 * common sequential file show function and write file operation.
 * The register number is recorded in private fields associated
 * with the sequential file and (for writable files) inode.
 */
static bool ipa_debugfs_regs_create(struct dentry *ipa_dir)
{
	static struct dentry *regs_dir;
	bool success;
	int i;

	regs_dir = debugfs_create_dir("regs", ipa_dir);
	if (IS_ERR(regs_dir))
		return false;

	success = ADD_REG_RO(regs_dir, IPA_VERSION);
	success = success && ADD_REG_RO(regs_dir, IPA_COMP_HW_VERSION);
	success = success && ADD_REG_RO(regs_dir, IPA_ROUTE);

	success = success && ADD_REG_FIELDS_RO(regs_dir, shared_mem_size);

	if (!success)
		return false;

	for (i = 0; i < ipa3_ctx->ipa_num_pipes; i++)
		if (!ipa_debugfs_regs_pipe_create(regs_dir, i))
			return false;

	return true;
}

/*
 * "ipa/stats/" is a directory containing statistical values.
 *
 * Files in this directory are read-only.  Each shows a 32-bit
 * unsigned value representing an accumulated statistic.  The
 * address of the statistic to be shown is held in the sequential
 * file private field.
 */
static bool ipa_debugfs_stats_create(struct dentry *ipa_dir)
{
	static struct dentry *stats_dir;
	static struct dentry *excp_dir;
	bool success;
	u32 i;

	stats_dir = debugfs_create_dir("stats", ipa_dir);
	if (IS_ERR(stats_dir))
		return false;

#define ADD_STAT(f)	_ADD_STAT(stats_dir, #f, &ipa3_ctx->stats.f)
	success = ADD_STAT(tx_sw_pkts);
	success = success && ADD_STAT(tx_hw_pkts);
	success = success && ADD_STAT(rx_pkts);
	success = success && ADD_STAT(rx_repl_repost);
	success = success && ADD_STAT(tx_pkts_compl);
	success = success && ADD_STAT(rx_q_len);
	success = success && ADD_STAT(stat_compl);
	success = success && ADD_STAT(aggr_close);
	success = success && ADD_STAT(wan_aggr_close);
	success = success && ADD_STAT(wan_rx_empty);
	success = success && ADD_STAT(wan_repl_rx_empty);
	success = success && ADD_STAT(lan_rx_empty);
	success = success && ADD_STAT(lan_repl_rx_empty);
	success = success && ADD_STAT(flow_enable);
	success = success && ADD_STAT(flow_disable);
	success = success && ADD_STAT(tx_non_linear);
#undef ADD_STAT

	if (!success)
		return false;

	excp_dir = debugfs_create_dir("rx_excp_pkts", stats_dir);
	if (IS_ERR(excp_dir))
		return false;

#define ADD_STAT(i)	_ADD_STAT(excp_dir,				\
				ipahal_pkt_status_exception_str(i),	\
				&ipa3_ctx->stats.rx_excp_pkts[i])
	for (i = 0; i < IPAHAL_PKT_STATUS_EXCEPTION_MAX; i++)
		if (!ADD_STAT(i))
			return false;
#undef ADD_STAT

	return true;
}

/*
 * "ipa/clients/active_count" shows the current active client
 * count.  If it is non-zero the IPA clock will remain active.
 *
 * The count can be incremented or decremented by writing a "+" or "-"
 * to this file.  Only the first character written is significant; all
 * characters past the first are ignored, and any other first character
 * value has no effect (and returns -EINVAL).
 *
 * Attempts to decrement the clock below zero (or above INT_MAX) are
 * also treated as errors and ignored.  The number of increments and
 * decrements made via this interface are tracked. the net effect
 * on the count cannot be negative.  In other words, the number of
 * decrements made this way cannot exceed the number of increments.
 */
static u32 sysfs_count;	/* Net changes via this interface */
static int active_count_show(struct seq_file *s, void *v)
{
	int active = atomic_read(&ipa3_ctx->ipa3_active_clients.cnt);

	seq_printf(s, "%d (including %u via sysfs)\n", active, sysfs_count);

	return 0;
}

static ssize_t active_count_write(struct file *file,
		const char __user *buf, size_t count, loff_t *ppos)
{
	int active;
	char byte;
	bool increment;

	if (get_user(byte, buf))
		return -EFAULT;

	if (byte != '+' && byte != '-')
		return -EINVAL;
	increment = byte == '+';

	/* We could race, but this is an informal interface */
	active = atomic_read(&ipa3_ctx->ipa3_active_clients.cnt);
	if (increment && (sysfs_count == U32_MAX || active == INT_MAX))
		return -ERANGE;
	else if (!increment && (!sysfs_count || !active))
		return -EPERM;

	if (increment) {
		sysfs_count++;
		ipa_client_add(__func__, false);
	} else {
		ipa_client_remove(__func__, false);
		--sysfs_count;
	}

	return count;
}
DEF_SEQ_RW(active_count);

/*
 * "ipa/clients/active" shows the currently IPA clients
 *
 * The active clients table is a list of active client entries.  The
 * entries are shown in the order they became active.  Each entry
 * provides its identifying string, along with a current reference
 * count.
 */
static int active_show(struct seq_file *s, void *v)
{
	struct ipa3_active_clients_log_ctx *log;
	struct ipa_active_client *entry;
	unsigned long flags;

	log = &ipa3_ctx->ipa3_active_clients_logging;

	spin_lock_irqsave(&log->lock, flags);

	seq_printf(s, "\n---- Active Clients Table ----\n");
	list_for_each_entry(entry, &log->active, links)
		seq_printf(s, "%-40s %-3d\n", entry->id_string, entry->count);
	seq_printf(s, "\nTotal active clients count: %d\n",
			atomic_read(&ipa3_ctx->ipa3_active_clients.cnt));

	spin_unlock_irqrestore(&log->lock, flags);

	return 0;
}
DEF_SEQ_RO(active);

/*
 * "ipa/clients/log" shows the log of recent IPA client.
 *
 * The active clients log is an array of formatted string pointers
 * treated as a circular buffer.  When we show it we show the oldest
 * entry, then the next oldest, and so on until the most recent
 * entry in the array has been shown.  The iterator value returned
 * is an index cast as a pointer; we add 1 to avoid index 0 being
 * represented as a null pointer.  Index value 1 represents the
 * first logged entry (which is determined by the log tail).
 */
static void *clients_log_start(struct seq_file *s, loff_t *pos)
{
	struct ipa3_active_clients_log_ctx *log;
	unsigned long flags;
	uintptr_t log_tail;
	u32 log_size;

	log = &ipa3_ctx->ipa3_active_clients_logging;
	log_size = ARRAY_SIZE(log->log_buffer);

	/* Limit output to the currently used entries in the log */
	spin_lock_irqsave(&log->lock, flags);
	log_tail = log->log_tail;
	log_size = (log_size + log->log_head - (log_tail + 1)) % log_size;
	spin_unlock_irqrestore(&log->lock, flags);

	if (*pos >= log_size)
		return NULL;

	s->private = (void *)log_tail;

	return (void *)(*pos + 1);
}

static void *clients_log_next(struct seq_file *s, void *v, loff_t *pos)
{
	struct ipa3_active_clients_log_ctx *log;
	unsigned long flags;
	uintptr_t log_tail;
	u32 log_size;

	log = &ipa3_ctx->ipa3_active_clients_logging;
	log_size = ARRAY_SIZE(log->log_buffer);

	/* Make sure tail hasn't moved, and compute number of used slots */
	spin_lock_irqsave(&log->lock, flags);
	log_tail = log->log_tail;
	log_size = (log_size + log->log_head - (log_tail + 1)) % log_size;
	spin_unlock_irqrestore(&log->lock, flags);

	if (s->private != (void *)log_tail) {
		ipa_info("active client log has changed (try again)\n");
		return NULL;
	}

	if ((uintptr_t)v < log_size)
		return (void *)(++*pos + 1);

	return NULL;
}

static void clients_log_stop(struct seq_file *s, void *v)
{
	/* Nothing to do */
}

static int clients_log_show(struct seq_file *s, void *v)
{
	struct ipa3_active_clients_log_ctx *log;
	unsigned long flags;
	uintptr_t index = (uintptr_t)v;	/* index provided starts at 1 */
	u32 lines;

	log = &ipa3_ctx->ipa3_active_clients_logging;
	lines = ARRAY_SIZE(log->log_buffer);

	if (index > lines)
		return -EINVAL;

	/*
	 * Convert index to the position in the circular log, then
	 * show that slot in the log.
	 */
	spin_lock_irqsave(&log->lock, flags);
	index = (log->log_tail + index) % lines;
	if (log->log_buffer[index])
		seq_printf(s, "%s\n", log->log_buffer[index]);
	spin_unlock_irqrestore(&log->lock, flags);

	return 0;
}

static const struct seq_operations clients_log_seq_ops = {
	.start	= clients_log_start,
	.next	= clients_log_next,
	.stop	= clients_log_stop,
	.show	= clients_log_show,
};

static int clients_log_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &clients_log_seq_ops);
}

/* Anything written to "log" causes it to be cleared */
static ssize_t clients_log_write(struct file *file,
		const char __user *buf, size_t count, loff_t *ppos)
{
	struct ipa3_active_clients_log_ctx *log;
	unsigned long flags;
	u32 lines;

	log = &ipa3_ctx->ipa3_active_clients_logging;
	lines = ARRAY_SIZE(log->log_buffer);

	spin_lock_irqsave(&log->lock, flags);

	log->log_head = 0;
	log->log_tail = lines - 1;

	spin_unlock_irqrestore(&log->lock, flags);

	return count;
}

static const struct file_operations clients_log_fops = {
	.owner		= THIS_MODULE,
	.open		= clients_log_open,
	.read		= seq_read,
	.write		= clients_log_write,
	.llseek		= seq_lseek,
	.release	= seq_release,
};

/*
 * "ipa/clients/" contains files related to the current and
 * recently-active IPA clients.
 */
static bool ipa_debugfs_clients_create(struct dentry *ipa_dir)
{
	static struct dentry *clients_dir;

	clients_dir = debugfs_create_dir("clients", ipa_dir);
	if (IS_ERR(clients_dir))
		return false;

	if (!ADD_SEQ_RW(clients_dir, active_count))
		return false;

	if (!ADD_SEQ_RO(clients_dir, active))
		return false;

	/* There's no log to show if the log buffer array has no entries */
	if (!ARRAY_SIZE(ipa3_ctx->ipa3_active_clients_logging.log_buffer))
		return true;

	return debugfs_create_file("log", S_IFREG|S_IRUGO|S_IWUSR, clients_dir,
					NULL, &clients_log_fops);
}

void ipa3_debugfs_init(void)
{
	static struct dentry *ipa_dir;
	const mode_t write_only_mode = S_IWUSR | S_IWGRP;
	const mode_t read_write_mode = S_IRUGO | write_only_mode;
	struct dentry *file;

	ipa_dir = debugfs_create_dir("ipa", NULL);
	if (IS_ERR(ipa_dir))
		goto fail;

	if (!ADD_SEQ_RW(ipa_dir, ipc_low_enabled))
		goto fail;

	if (!ipa_debugfs_regs_create(ipa_dir))
		goto fail;

	if (!ipa_debugfs_stats_create(ipa_dir))
		goto fail;

	if (!ipa_debugfs_clients_create(ipa_dir))
		goto fail;

	file = debugfs_create_file("active_clients", S_IFREG|S_IRUGO,
			ipa_dir, 0, &ipa3_active_clients);
	if (IS_ERR_OR_NULL(file))
		goto fail;

	file = debugfs_create_file("holb", write_only_mode,
			ipa_dir,
			0, &ipa3_ep_holb_ops);
	if (IS_ERR_OR_NULL(file))
		goto fail;

	/*
	 * Starting with IPA hardware 4.0, registers IPA_DEBUG_CNT_REG_n
	 * and IPA_DEBUG_CNT_CTRL_n will no longer be supported.  These
	 * registers are read and written (respectively) by debugfs
	 * file "dbg_cnt" created here.  Once we support newer
	 * versions of IPA hardware, creating "debug_cnt" should be
	 * done conditionally to avoid accessing unsupported registers.
	 */
	file = debugfs_create_file("dbg_cnt",
			read_write_mode, ipa_dir, 0,
			&ipa3_dbg_cnt_ops);
	if (IS_ERR_OR_NULL(file))
		goto fail;

	file = debugfs_create_file("status_stats",
			S_IRUGO, ipa_dir, 0, &ipa3_status_stats_ops);
	if (IS_ERR_OR_NULL(file))
		goto fail;

	file = debugfs_create_file("enable_clock_scaling", S_IRUGO, ipa_dir,
			"1\n", &const_string_fops);
	if (!file)
		goto fail;

	file = debugfs_create_u32("clock_scaling_bw_threshold_nominal_mbps",
		read_write_mode, ipa_dir,
		&ipa3_ctx->ctrl->clock_scaling_bw_threshold_nominal);
	if (!file)
		goto fail;

	file = debugfs_create_u32("clock_scaling_bw_threshold_turbo_mbps",
		read_write_mode, ipa_dir,
		&ipa3_ctx->ctrl->clock_scaling_bw_threshold_turbo);
	if (!file)
		goto fail;

	active_clients_buf = kzalloc(IPA_DBG_ACTIVE_CLIENT_BUF_SIZE,
			GFP_KERNEL);
	if (active_clients_buf)
		return;
fail:
	ipa_err("error while creating ipa debugfs hierarchy\n");
	debugfs_remove_recursive(ipa_dir);
}

#else /* !CONFIG_DEBUG_FS */
void ipa3_debugfs_init(void) {}
#endif
