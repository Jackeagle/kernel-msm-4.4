// SPDX-License-Identifier: GPL-2.0

/* Copyright (c) 2015-2018, The Linux Foundation. All rights reserved.
 * Copyright (C) 2018 Linaro Ltd.
 */
#ifndef _GSI_H_
#define _GSI_H_

#include <linux/types.h>
#include <linux/platform_device.h>

#include "ipa_dma.h"

#define GSI_RING_ELEMENT_SIZE	16	/* bytes (channel or event ring) */

/**
 * struct ipa_gsi_ep_config - GSI endpoint configuration.
 * @ep_id:	IPA endpoint identifier.
 * @channel_id:	GSI channel number used for this endpoint.
 * @ipa_if_tlv:	The number of TLV (type-length-value) entries for the endpoint.
 * @ipa_if_aos:	The number of AOS (ACK-on-success) entries for the endpoint.
 * @ee:		Execution environment endpoint is associated with.
 *
 * Each GSI endpoint has a set of configuration parameters defined within
 * entries in the ipa_ep_configuration[] array.  Its @ep_id field uniquely
 * defines the endpoint, and @channel_id defines which data channel (ring
 * buffer) is used for the endpoint.
 * XXX TLV and AOS
 * XXX ipa_if_aos and ee are never used in the code
 */
struct ipa_gsi_ep_config {
	u32 ep_id;
	u32 channel_id;
	u32 ipa_if_tlv;
	u32 ipa_if_aos;
	u32 ee;
};

/**
 * enum gsi_xfer_flag - Transfer element flag values.
 * @GSI_XFER_FLAG_CHAIN:	Not the last element in a transaction.
 * @GSI_XFER_FLAG_EOB:		Generate event interrupt when complete.
 * @GSI_XFER_FLAG_EOT:		Interrupt on end of transfer condition.
 * @GSI_XFER_FLAG_BEI:		Block (do not generate) event interrupt.
 *
 * Normally an event generated by completion of a transfer will cause
 * the AP to be interrupted; the BEI flag prevents that.
 */
enum gsi_xfer_flag {
	GSI_XFER_FLAG_CHAIN	= 0x1,
	GSI_XFER_FLAG_EOB	= 0x100,
	GSI_XFER_FLAG_EOT	= 0x200,
	GSI_XFER_FLAG_BEI	= 0x400
};

/**
 * enum gsi_xfer_elem_type - Transfer element type.
 * @GSI_XFER_ELEM_DATA:		Element represents a data transfer
 * @GSI_XFER_ELEM_IMME_CMD:	Element contains an immediate command.
 * @GSI_XFER_ELEM_NOP:		Element contans a no-op command.
 */
enum gsi_xfer_elem_type {
	GSI_XFER_ELEM_DATA,
	GSI_XFER_ELEM_IMME_CMD,
	GSI_XFER_ELEM_NOP,
};

/**
 * gsi_xfer_elem - Description of a single transfer element.
 * @addr:	Physical address of a buffer for data or immediate commands.
 * @len:	Length of the data buffer, or immediate command opcode.
 * @flags:	XXX enum gsi_xfer_flag
 * @type:	XXX enum gsi_xfer_elem_type
 * @user_data:	Data maintained for (but unused by) the transfer element.
 */
struct gsi_xfer_elem {
	u64 addr;
	u16 len;
	u16 flags;
	enum gsi_xfer_elem_type type;
	void *user_data;
};

struct gsi;

struct gsi *gsi_init(struct platform_device *pdev);

/** gsi_register_device - Peripheral should call this function to
 * register itself with GSI before invoking any other APIs
 *
 * @Return 0 if successful or a negative error code otherwise.
 */
int gsi_register_device(struct gsi *gsi);

/** gsi_deregister_device - Peripheral should call this function to
 * de-register itself with GSI
 */
void gsi_deregister_device(struct gsi *gsi);

/** gsi_alloc_channel - Peripheral should call this function to
 * allocate a channel once gsi_register_device() has been called
 *
 * @Return Channel handle populated by GSI, opaque to client, or negative errno
 */
int gsi_alloc_channel(struct gsi *gsi, u32 channel_id, u32 channel_count,
		      bool from_ipa, bool priority, u32 evt_ring_mult,
		      bool moderation, void *notify_data);

/** gsi_write_channel_scratch - Peripheral should call this function to
 * write to the scratch area of the channel context
 *
 * @channel_id:  Client handle previously obtained from gsi_alloc_channel
 * @tlv_size:  Number of elements in channel TLV queue
 *
 * @Return gsi_status
 */
void gsi_write_channel_scratch(struct gsi *gsi, u32 channel_id, u32 tlv_size);

/** gsi_start_channel - Peripheral should call this function to
 * start a channel i.e put into running state
 *
 * @channel_id:  Client handle previously obtained from
 *	       gsi_alloc_channel
 *
 * This function can sleep
 *
 * @Return gsi_status
 */
int gsi_start_channel(struct gsi *gsi, u32 channel_id);

/** gsi_stop_channel - Peripheral should call this function to
 * stop a channel. Stop will happen on a packet boundary
 *
 * @channel_id:  Client handle previously obtained from
 *	       gsi_alloc_channel
 *
 * This function can sleep
 *
 * @Return -GSI_STATUS_AGAIN if client should call stop/stop_db again
 *	   other error codes for failure
 */
int gsi_stop_channel(struct gsi *gsi, u32 channel_id);

/** gsi_reset_channel - Peripheral should call this function to
 * reset a channel to recover from error state
 *
 * @channel_id:  Client handle previously obtained from
 *	       gsi_alloc_channel
 *
 * This function can sleep
 *
 * @Return gsi_status
 */
int gsi_reset_channel(struct gsi *gsi, u32 channel_id);

/** gsi_dealloc_channel - Peripheral should call this function to
 * de-allocate a channel
 *
 * @channel_id:  Client handle previously obtained from gsi_alloc_channel()
 *
 * This function can sleep
 */
void gsi_dealloc_channel(struct gsi *gsi, u32 channel_id);

/** gsi_set_channel_cfg() - Configure a channel
 * @gsi:		GSI pointer
 * @channel_id:		Channel to be configured
 * @doorbell_enable:	Whether to enable hardware doorbell engine
 *
 */
void gsi_set_channel_cfg(struct gsi *gsi, u32 channel_id, bool doorbell_enable);

/** gsi_poll_channel() - Poll for a single completion on a channel
 * @gsi:	GSI pointer
 * @channel_id:	Channel to be polled
 *
 * @Return:	Byte transfer count on success, or a negative error code
 */
int gsi_poll_channel(struct gsi *gsi, u32 channel_id);

/** gsi_channel_intr_enable() - Enable interrupts on a channel
 * @gsi:	GSI pointer
 * @channel_id:	Channel whose interrupts should be enabled
 */
void gsi_channel_intr_enable(struct gsi *gsi, u32 channel_id);

/** gsi_channel_intr_disable() - Disable interrupts on a channel
 * @gsi:	GSI pointer
 * @channel_id:	Channel whose interrupts should be disabled
 */
void gsi_channel_intr_disable(struct gsi *gsi, u32 channel_id);

/** gsi_queue_xfer() - Queue transfer requests on a channel
 * @gsi:	GSI pointer
 * @channel_id:	Channel on which transfers should be queued
 * @num_xfers:	Number of transfer in the @xfer array
 * @xfer:	Array of transfer descriptors
 * @ring_db:	Whether to tell HW about these queued xfers
 *
 * @Return:	0 on success, or a negative error code
 */
int gsi_queue_xfer(struct gsi *gsi, u32 channel_id, u16 num_xfers,
		   struct gsi_xfer_elem *xfer, bool ring_db);

#endif /* _GSI_H_ */
