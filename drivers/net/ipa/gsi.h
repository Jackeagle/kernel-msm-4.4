// SPDX-License-Identifier: GPL-2.0

/* Copyright (c) 2015-2018, The Linux Foundation. All rights reserved.
 * Copyright (C) 2018 Linaro Ltd.
 */
#ifndef _GSI_H_
#define _GSI_H_

#include <linux/types.h>
#include <linux/platform_device.h>

#include "ipa_dma.h"

#define GSI_RING_ELEMENT_SIZE	16	/* bytes (channel or event ring) */

/**
 * struct ipa_gsi_ep_config - GSI endpoint configuration.
 * @ep_id:	IPA endpoint identifier.
 * @channel_id:	GSI channel number used for this endpoint.
 * @ipa_if_tlv:	The number of TLV (type-length-value) entries for the endpoint.
 * @ipa_if_aos:	The number of AOS (ACK-on-success) entries for the endpoint.
 * @ee:		Execution environment endpoint is associated with.
 *
 * Each GSI endpoint has a set of configuration parameters defined within
 * entries in the ipa_ep_configuration[] array.  Its @ep_id field uniquely
 * defines the endpoint, and @channel_id defines which data channel (ring
 * buffer) is used for the endpoint.
 * XXX TLV and AOS
 * XXX ipa_if_aos and ee are never used in the code
 */
struct ipa_gsi_ep_config {
	u32 ep_id;
	u32 channel_id;
	u32 ipa_if_tlv;
	u32 ipa_if_aos;
	u32 ee;
};

/**
 * gsi_channel_props - Properties of a data channel.
 * @mem:		The DMA memory containing the channel's ring buffer.
 * @ring_count:		The number of entries in the ring buffer.
 * @from_gsi:		The direction of the channel data flow.
 * @use_db_engine:	XXX Whether to use the doorbell engine.
 * @low_weight:		XXX Relative priority of this channel.
 * @channel_id:		Which GSI channel this is.
 * @evt_ring_id:	The event ring associated with this channel.
 * @user_data:		Data maintained for (but unused by) the channel.
 */
struct gsi_channel_props {
	bool from_gsi;
	bool use_db_engine;
	u8 low_weight;
	void *user_data;
};

/**
 * enum gsi_xfer_flag - Transfer element flag values.
 * @GSI_XFER_FLAG_CHAIN:	Not the last element in a transaction.
 * @GSI_XFER_FLAG_EOB:		Generate event interrupt when complete.
 * @GSI_XFER_FLAG_EOT:		Interrupt on end of transfer condition.
 * @GSI_XFER_FLAG_BEI:		Block (do not generate) event interrupt.
 *
 * Normally an event generated by completion of a transfer will cause
 * the AP to be interrupted; the BEI flag prevents that.
 */
enum gsi_xfer_flag {
	GSI_XFER_FLAG_CHAIN	= 0x1,
	GSI_XFER_FLAG_EOB	= 0x100,
	GSI_XFER_FLAG_EOT	= 0x200,
	GSI_XFER_FLAG_BEI	= 0x400
};

/**
 * enum gsi_xfer_elem_type - Transfer element type.
 * @GSI_XFER_ELEM_DATA:		Element represents a data transfer
 * @GSI_XFER_ELEM_IMME_CMD:	Element contains an immediate command.
 * @GSI_XFER_ELEM_NOP:		Element contans a no-op command.
 */
enum gsi_xfer_elem_type {
	GSI_XFER_ELEM_DATA,
	GSI_XFER_ELEM_IMME_CMD,
	GSI_XFER_ELEM_NOP,
};

/**
 * gsi_xfer_elem - Description of a single transfer element.
 * @addr:	Physical address of a buffer for data or immediate commands.
 * @len:	Length of the data buffer, or immediate command opcode.
 * @flags:	XXX enum gsi_xfer_flag
 * @type:	XXX enum gsi_xfer_elem_type
 * @user_data:	Data maintained for (but unused by) the transfer element.
 */
struct gsi_xfer_elem {
	u64 addr;
	u16 len;
	u16 flags;
	enum gsi_xfer_elem_type type;
	void *user_data;
};

struct gsi;

struct gsi *gsi_init(struct platform_device *pdev);

/** gsi_register_device - Peripheral should call this function to
 * register itself with GSI before invoking any other APIs
 *
 * @Return 0 if successful or a negative error code otherwise.
 */
int gsi_register_device(struct gsi *gsi);

/** gsi_deregister_device - Peripheral should call this function to
 * de-register itself with GSI
 */
void gsi_deregister_device(struct gsi *gsi);

/** gsi_evt_ring_alloc - Peripheral should call this function to
 * allocate an event ring once gsi_register_device() has been called
 *
 * This function can sleep
 *
 * @Return id for event ring populated by GSI, or a negative errno
 */
int gsi_evt_ring_alloc(struct gsi *gsi, u32 ring_count, bool moderation);

/** gsi_evt_ring_dealloc - Peripheral should call this function to
 * de-allocate an event ring. There should not exist any active
 * channels using this event ring
 *
 * @evt_id:  event ring id previously obtained from gsi_evt_ring_alloc
 *
 * This function can sleep
 */
void gsi_evt_ring_dealloc(struct gsi *gsi, u32 evt_id);

/** gsi_alloc_channel - Peripheral should call this function to
 * allocate a channel once gsi_register_device() has been called
 *
 * @props:     Channel properties
 *
 * This function can sleep
 *
 * @Return Channel handle populated by GSI, opaque to client, or negative errno
 */
int gsi_alloc_channel(struct gsi *gsi, u32 channel_id, u32 channel_count,
		      u32 evt_ring_id, struct gsi_channel_props *props);

/** gsi_write_channel_scratch - Peripheral should call this function to
 * write to the scratch area of the channel context
 *
 * @channel_id:  Client handle previously obtained from gsi_alloc_channel
 * @tlv_size:  Number of elements in channel TLV queue
 *
 * @Return gsi_status
 */
void gsi_write_channel_scratch(struct gsi *gsi, u32 channel_id, u32 tlv_size);

/** gsi_start_channel - Peripheral should call this function to
 * start a channel i.e put into running state
 *
 * @channel_id:  Client handle previously obtained from
 *	       gsi_alloc_channel
 *
 * This function can sleep
 *
 * @Return gsi_status
 */
int gsi_start_channel(struct gsi *gsi, u32 channel_id);

/** gsi_stop_channel - Peripheral should call this function to
 * stop a channel. Stop will happen on a packet boundary
 *
 * @channel_id:  Client handle previously obtained from
 *	       gsi_alloc_channel
 *
 * This function can sleep
 *
 * @Return -GSI_STATUS_AGAIN if client should call stop/stop_db again
 *	   other error codes for failure
 */
int gsi_stop_channel(struct gsi *gsi, u32 channel_id);

/** gsi_reset_channel - Peripheral should call this function to
 * reset a channel to recover from error state
 *
 * @channel_id:  Client handle previously obtained from
 *	       gsi_alloc_channel
 *
 * This function can sleep
 *
 * @Return gsi_status
 */
int gsi_reset_channel(struct gsi *gsi, u32 channel_id);

/** gsi_dealloc_channel - Peripheral should call this function to
 * de-allocate a channel
 *
 * @channel_id:  Client handle previously obtained from gsi_alloc_channel()
 *
 * This function can sleep
 */
void gsi_dealloc_channel(struct gsi *gsi, u32 channel_id);

/** gsi_get_channel_cfg - This function returns the current config
 * of the specified channel
 *
 * @channel_id:  Client handle previously obtained from
 *	       gsi_alloc_channel
 * @props:     where to copy properties to
 */
void gsi_get_channel_cfg(struct gsi *gsi, u32 channel_id,
			 struct gsi_channel_props *props);

/** gsi_set_channel_cfg - This function applies the supplied config
 * to the specified channel
 *
 * channel_id and evt_ring_id of the channel cannot be changed after
 * gsi_alloc_channel
 *
 * @channel_id:  Client handle previously obtained from gsi_alloc_channel
 * @props:     the properties to apply
 *
 * @Return gsi_status
 */
int gsi_set_channel_cfg(struct gsi *gsi, u32 channel_id,
			struct gsi_channel_props *props);

/** gsi_poll_channel - Peripheral should call this function to query for
 * completed transfer descriptors.
 *
 * @channel_id:  Client handle previously obtained from gsi_alloc_channel()
 *
 * @Return number of bytes transferred, or a negative error code
 */
int gsi_poll_channel(struct gsi *gsi, u32 channel_id);

/** gsi_channel_intr_enable/disable - control channel interrupts
 *
 * @channel_id:  Client handle previously obtained from gsi_alloc_channel()
 */
void gsi_channel_intr_enable(struct gsi *gsi, u32 channel_id);
void gsi_channel_intr_disable(struct gsi *gsi, u32 channel_id);

/** gsi_queue_xfer - Peripheral should call this function
 * to queue transfers on the given channel
 *
 * @channel_id:  Client handle previously obtained from gsi_alloc_channel()
 * @num_xfers: Number of transfer in the array @ xfer
 * @xfer:      Array of num_xfers transfer descriptors
 * @ring_db:   If true, tell HW about these queued xfers
 *	       If false, do not notify HW at this time
 *
 * @Return gsi_status
 */
int gsi_queue_xfer(struct gsi *gsi, u32 channel_id, u16 num_xfers,
		   struct gsi_xfer_elem *xfer, bool ring_db);

#endif /* _GSI_H_ */
