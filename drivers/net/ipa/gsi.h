// SPDX-License-Identifier: GPL-2.0

/* Copyright (c) 2015-2018, The Linux Foundation. All rights reserved.
 * Copyright (C) 2018 Linaro Ltd.
 */
#ifndef _GSI_H_
#define _GSI_H_

#include <linux/types.h>
#include <linux/platform_device.h>

#define GSI_RING_ELEMENT_SIZE	16	/* bytes (channel or event ring) */

/**
 * enum gsi_xfer_flag - Transfer element flag values.
 * @GSI_XFER_FLAG_CHAIN:	Not the last element in a transaction.
 * @GSI_XFER_FLAG_EOB:		Generate event interrupt when complete.
 * @GSI_XFER_FLAG_EOT:		Interrupt on end of transfer condition.
 * @GSI_XFER_FLAG_BEI:		Block (do not generate) event interrupt.
 *
 * Normally an event generated by completion of a transfer will cause
 * the AP to be interrupted; the BEI flag prevents that.
 */
enum gsi_xfer_flag {
	GSI_XFER_FLAG_CHAIN	= BIT(1),
	GSI_XFER_FLAG_EOB	= BIT(2),
	GSI_XFER_FLAG_EOT	= BIT(3),
	GSI_XFER_FLAG_BEI	= BIT(4),
};

/**
 * enum gsi_xfer_elem_type - Transfer element type.
 * @GSI_XFER_ELEM_DATA:		Element represents a data transfer
 * @GSI_XFER_ELEM_IMME_CMD:	Element contains an immediate command.
 * @GSI_XFER_ELEM_NOP:		Element contans a no-op command.
 */
enum gsi_xfer_elem_type {
	GSI_XFER_ELEM_DATA,
	GSI_XFER_ELEM_IMME_CMD,
	GSI_XFER_ELEM_NOP,
};

/**
 * gsi_xfer_elem - Description of a single transfer.
 * @addr:	Physical address of a buffer for data or immediate commands.
 * @len_opcode:	Length of the data buffer, or enum ipahal_imm_cmd opcode
 * @flags:	Flags for the transfer
 * @type:	Command type (immediate command, data transfer NOP)
 * @user_data:	Data maintained for (but unused by) the transfer element.
 */
struct gsi_xfer_elem {
	u64 addr;
	u16 len_opcode;
	enum gsi_xfer_flag flags;
	enum gsi_xfer_elem_type type;
	void *user_data;
};

struct gsi;

/**
 * gsi_init() - Initialize GSI subsystem
 * @pdev:	IPA platform device, to look up resources
 *
 * This stage of initialization can occur before the GSI firmware
 * has been loaded.
 *
 * Return:	GSI pointer to provide to other GSI functions.
 */
struct gsi *gsi_init(struct platform_device *pdev);

/**
 * gsi_device_init() - Initialize a GSI device
 * @gsi:	GSI pointer returned by gsi_init()
 *
 * Initialize a GSI device.
 *
 * @Return:	0 if successful or a negative error code otherwise.
 */
int gsi_device_init(struct gsi *gsi);

/**
 * gsi_device_exit() - De-initialize a GSI device
 * @gsi:	GSI pointer returned by gsi_init()
 *
 * This is the inverse of gsi_device_init()
 */
void gsi_device_exit(struct gsi *gsi);

/**
 * gsi_channel_alloc() - Allocate a GSI channel
 * @gsi:	GSI pointer returned by gsi_init()
 * @channel_id:	Channel to allocate
 * @channel_count: Number of transfer element slots in the channel
 * @from_ipa:	Direction of data transfer (true: IPA->AP; false: AP->IPA)
 * @priority:	Whether this channel will given prioroity
 * @evt_ring_mult: Factor to use to get the number of elements in the
 *		event ring associated with this channel
 * @moderation:	Whether interrupt moderation should be enabled
 * @notify_data: Pointer value to supply with notifications that
 * 		occur because of events on this channel
 *
 * @Return:	 0 if successful, or a negative error code.
 */
int gsi_channel_alloc(struct gsi *gsi, u32 channel_id, u32 channel_count,
		      bool from_ipa, bool priority, u32 evt_ring_mult,
		      bool moderation, void *notify_data);

/**
 * gsi_channel_scratch_write() - Write channel scratch area
 * @gsi:	GSI pointer returned by gsi_init()
 * @channel_id:	Channel whose scratch area should be written
 * @tlv_count:	The number of type-length-value the channel uses
 */
void gsi_channel_scratch_write(struct gsi *gsi, u32 channel_id, u32 tlv_count);

/**
 * gsi_channel_start() - Make a channel operational
 * @gsi:	GSI pointer returned by gsi_init()
 * @channel_id:	Channel to start
 *
 * @Return:	 0 if successful, or a negative error code.
 */
int gsi_channel_start(struct gsi *gsi, u32 channel_id);

/**
 * gsi_channel_stop() - Stop an operational channel
 * @gsi:	GSI pointer returned by gsi_init()
 * @channel_id:	Channel to stop
 *
 * @Return:	 0 if successful, or a negative error code.
 */
int gsi_channel_stop(struct gsi *gsi, u32 channel_id);

/**
 * gsi_channel_reset() - Reset a channel, to recover from error state
 * @gsi:	GSI pointer returned by gsi_init()
 * @channel_id:	Channel to be reset
 *
 * @Return:	 0 if successful, or a negative error code.
 */
int gsi_channel_reset(struct gsi *gsi, u32 channel_id);

/**
 * gsi_channel_free() - Release a previously-allocated channel
 * @gsi:	GSI pointer returned by gsi_init()
 * @channel_id:	Channel to be freed
 */
void gsi_channel_free(struct gsi *gsi, u32 channel_id);

/**
 * gsi_channel_config() - Configure a channel
 * @gsi:		GSI pointer returned by gsi_init()
 * @channel_id:		Channel to be configured
 * @doorbell_enable:	Whether to enable hardware doorbell engine
 */
void gsi_channel_config(struct gsi *gsi, u32 channel_id, bool doorbell_enable);

/**
 * gsi_channel_poll() - Poll for a single completion on a channel
 * @gsi:	GSI pointer returned by gsi_init()
 * @channel_id:	Channel to be polled
 *
 * @Return:	Byte transfer count if successful, or a negative error code
 */
int gsi_channel_poll(struct gsi *gsi, u32 channel_id);

/**
 * gsi_channel_intr_enable() - Enable interrupts on a channel
 * @gsi:	GSI pointer returned by gsi_init()
 * @channel_id:	Channel whose interrupts should be enabled
 */
void gsi_channel_intr_enable(struct gsi *gsi, u32 channel_id);

/**
 * gsi_channel_intr_disable() - Disable interrupts on a channel
 * @gsi:	GSI pointer returned by gsi_init()
 * @channel_id:	Channel whose interrupts should be disabled
 */
void gsi_channel_intr_disable(struct gsi *gsi, u32 channel_id);

/**
 * gsi_channel_queue() - Queue transfer requests on a channel
 * @gsi:	GSI pointer returned by gsi_init()
 * @channel_id:	Channel on which transfers should be queued
 * @num_xfers:	Number of transfer descriptors in the @xfer array
 * @xfer:	Array of transfer descriptors
 * @ring_db:	Whether to tell the hardware about these queued transfers
 *
 * @Return:	0 if successful, or a negative error code
 */
int gsi_channel_queue(struct gsi *gsi, u32 channel_id, u16 num_xfers,
		      struct gsi_xfer_elem *xfer, bool ring_db);

#endif /* _GSI_H_ */
